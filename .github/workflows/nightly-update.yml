name: nightly-dependency-update

on:
  schedule:
    - cron: '0 0 * * *'
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

jobs:
  update:
    runs-on: windows-latest
    env:
      CONFIGURATION: ${{ github.event.inputs.configuration || 'Release' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install .NET SDK (LTS)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $installDir = Join-Path $env:USERPROFILE ".dotnet"
          Invoke-WebRequest https://dot.net/v1/dotnet-install.ps1 -OutFile dotnet-install.ps1
          ./dotnet-install.ps1 -Channel LTS -InstallDir $installDir
          Add-Content -Path $env:GITHUB_PATH -Value $installDir
          Add-Content -Path $env:GITHUB_ENV -Value "DOTNET_ROOT=$installDir"

      - name: Install .NET SDK (8.0)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $installDir = Join-Path $env:USERPROFILE ".dotnet8"
          Invoke-WebRequest https://dot.net/v1/dotnet-install.ps1 -OutFile dotnet-install.ps1
          ./dotnet-install.ps1 -Channel 8.0 -InstallDir $installDir
          Add-Content -Path $env:GITHUB_ENV -Value "DOTNET_8_ROOT=$installDir"
          Add-Content -Path $env:GITHUB_PATH -Value $installDir

      - name: Install dotnet-outdated-tool
        shell: pwsh
        env:
          DOTNET_ROOT: ${{ env.DOTNET_8_ROOT }}
          DOTNET_MULTILEVEL_LOOKUP: 0
        run: |
          $dotnet8 = Join-Path $env:DOTNET_8_ROOT "dotnet.exe"
          & $dotnet8 tool install --global dotnet-outdated-tool

      - name: List installed workloads
        shell: pwsh
        env:
          DOTNET_ROOT: ${{ env.DOTNET_8_ROOT }}
          DOTNET_MULTILEVEL_LOOKUP: 0
        run: |
          $dotnet8 = Join-Path $env:DOTNET_8_ROOT "dotnet.exe"
          & $dotnet8 workload list

      - name: List available workloads
        shell: pwsh
        env:
          DOTNET_ROOT: ${{ env.DOTNET_8_ROOT }}
          DOTNET_MULTILEVEL_LOOKUP: 0
        run: |
          $dotnet8 = Join-Path $env:DOTNET_8_ROOT "dotnet.exe"
          & $dotnet8 workload search

      - name: Update NuGet packages
        shell: pwsh
        env:
          DOTNET_ROOT: ${{ env.DOTNET_8_ROOT }}
          DOTNET_MULTILEVEL_LOOKUP: 0
        run: |
          $dotnet8 = Join-Path $env:DOTNET_8_ROOT "dotnet.exe"
          & $dotnet8 outdated Launcher_WPF/Launcher_WPF.csproj -u -rt win-x64
          & $dotnet8 outdated MeineApp/MeineApp.csproj -u -rt win-x64

      - name: Update target framework to latest .NET LTS
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $dotnetLts = Join-Path $env:DOTNET_ROOT "dotnet.exe"
          $ltsMajor = & $dotnetLts --list-sdks |
            ForEach-Object { ($_ -split '\s+')[0] } |
            ForEach-Object { ($_ -split '\.')[0] } |
            Sort-Object {[int]$_} |
            Select-Object -Last 1

          if (-not $ltsMajor) {
            Write-Error "Could not determine .NET SDK major version."
            exit 1
          }

          $replacement = "<TargetFramework>net$ltsMajor.0-windows</TargetFramework>"
          $projects = @(
            "Launcher_WPF/Launcher_WPF.csproj",
            "MeineApp/MeineApp.csproj"
          )

          foreach ($project in $projects) {
            (Get-Content $project) -replace "<TargetFramework>net[0-9]+\.0-windows</TargetFramework>", $replacement |
              Set-Content $project
          }

      - name: Configure DesktopBridge path
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $desktopBridgePath = Join-Path ${env:ProgramFiles(x86)} "MSBuild\Microsoft\DesktopBridge\"
          $propsPath = Join-Path $desktopBridgePath "Microsoft.DesktopBridge.props"

          if (-not (Test-Path $propsPath)) {
            Write-Warning "DesktopBridge props not found at $propsPath. Skipping MSIX packaging build."
            Add-Content -Path $env:GITHUB_ENV -Value "DesktopBridgeAvailable=false"
            return
          }

          Add-Content -Path $env:GITHUB_ENV -Value "WapProjPath=$desktopBridgePath"
          Add-Content -Path $env:GITHUB_ENV -Value "DesktopBridgeAvailable=true"

      - name: Build solution
        shell: pwsh
        run: |
          $dotnetLts = Join-Path $env:DOTNET_ROOT "dotnet.exe"
          if ($env:DesktopBridgeAvailable -eq "true") {
            & $dotnetLts build Launcher.sln -c Release
            return
          }

          & $dotnetLts build Launcher_WPF/Launcher_WPF.csproj -c Release
          & $dotnetLts build MeineApp/MeineApp.csproj -c Release

      - name: Show installed SDK
        shell: pwsh
        run: dotnet --version

      - name: Setup NuGet
        uses: NuGet/setup-nuget@v2

      - name: Restore NuGet packages
        shell: pwsh
        env:
          DOTNET_MULTILEVEL_LOOKUP: 0
        run: |
          $installDir = Join-Path $env:USERPROFILE ".dotnet"
          $dotnet = Join-Path $installDir "dotnet.exe"
          & $dotnet nuget restore Launcher.sln
          
      - name: Resolve package version
        id: versioning
        shell: pwsh
        env:
          VERSION_INPUT: "v1.0.0.0"
        run: |
          $version = $env:VERSION_INPUT

          if (-not $version) {
            if ("${{ github.ref }}".StartsWith("refs/tags/")) {
              $version = "${{ github.ref_name }}".TrimStart("v")
            }
          }

          if (-not $version) {
            Write-Error "Keine Versionsangabe gefunden. Starte den Workflow per Tag (vX.X.X.X) oder über workflow_dispatch mit 'version'."
            exit 1
          }

          $version = $version.Trim()
          if ($version -notmatch '^\d+(\.\d+){0,3}$') {
            Write-Error "Ungültiges Versionsformat '$version'. Erwartet wird z.B. 1.2.3.4 (aus Tag v1.2.3.4)."
            exit 1
          }

          $parts = $version.Split('.')
          while ($parts.Count -lt 4)
          {
            $parts += "0"
          }
          $version = ($parts -join '.')

          "BUILD_VERSION=$version" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          "version=$version" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Setup MSBuild
        uses: microsoft/setup-msbuild@v2
        with:
          vs-version: latest

      - name: Prepare signing certificate
        id: signing
        shell: pwsh
        env:
          SIGNING_CERTIFICATE_BASE64: ${{ secrets.MSIX_SIGNING_CERTIFICATE_BASE64 }}
          SIGNING_CERTIFICATE_PASSWORD: ${{ secrets.MSIX_SIGNING_CERTIFICATE_PASSWORD }}
          DEFAULT_PFX_BASE64_PATH: ${{ github.workspace }}/certificates/msix_signing.pfx.b64
          DEFAULT_CER_BASE64_PATH: ${{ github.workspace }}/certificates/msix_signing.cer.b64
          DEFAULT_PFX_PASSWORD: msix-dev-password
        run: |
          $ErrorActionPreference = 'Stop'

          $pfxPath = Join-Path $env:RUNNER_TEMP "signing_cert.pfx"
          $cerPath = Join-Path $env:RUNNER_TEMP "signing_cert.cer"
          $password = $env:SIGNING_CERTIFICATE_PASSWORD
          $securePassword = $null

          if ($env:SIGNING_CERTIFICATE_BASE64) {
            Write-Host "Using signing certificate from secret."
            if (-not $password) {
              Write-Error "SIGNING_CERTIFICATE_PASSWORD secret is required when providing SIGNING_CERTIFICATE_BASE64."
              exit 1
            }

            $bytes = [Convert]::FromBase64String($env:SIGNING_CERTIFICATE_BASE64)
            [IO.File]::WriteAllBytes($pfxPath, $bytes)
            $securePassword = ConvertTo-SecureString -String $password -Force -AsPlainText
            $imported = Import-PfxCertificate -FilePath $pfxPath -Password $securePassword -CertStoreLocation Cert:\CurrentUser\My
            Export-Certificate -Cert $imported -FilePath $cerPath | Out-Null
          }
          elseif (Test-Path $env:DEFAULT_PFX_BASE64_PATH) {
            Write-Host "Using repository signing certificate from $($env:DEFAULT_PFX_BASE64_PATH)."
            $base64 = Get-Content -Path $env:DEFAULT_PFX_BASE64_PATH -Raw
            $bytes = [Convert]::FromBase64String($base64)
            [IO.File]::WriteAllBytes($pfxPath, $bytes)
            $password = $env:DEFAULT_PFX_PASSWORD
            $securePassword = ConvertTo-SecureString -String $password -Force -AsPlainText
            $imported = Import-PfxCertificate -FilePath $pfxPath -Password $securePassword -CertStoreLocation Cert:\CurrentUser\My
            if (Test-Path $env:DEFAULT_CER_BASE64_PATH) {
              $cerBase64 = Get-Content -Path $env:DEFAULT_CER_BASE64_PATH -Raw
              $cerBytes = [Convert]::FromBase64String($cerBase64)
              [IO.File]::WriteAllBytes($cerPath, $cerBytes)
            }
            else {
              Export-Certificate -Cert $imported -FilePath $cerPath | Out-Null
            }
          }
          else {
            Write-Host "No signing certificate secret provided. Generating a temporary self-signed certificate."
            $password = [Guid]::NewGuid().ToString("N")
            $securePassword = ConvertTo-SecureString -String $password -Force -AsPlainText
            $cert = New-SelfSignedCertificate -Type CodeSigningCert -Subject "CN=MSIX Installer" -CertStoreLocation Cert:\CurrentUser\My
            Export-PfxCertificate -Cert $cert -FilePath $pfxPath -Password $securePassword | Out-Null
            Export-Certificate -Cert $cert -FilePath $cerPath | Out-Null
          }

          "signing_pfx_path=$pfxPath" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          "signing_pfx_password=$password" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          "signing_cer_path=$cerPath" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

      - name: Build MSIX bundle
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $packageDir = Join-Path $env:RUNNER_TEMP "msix"
          New-Item -ItemType Directory -Force -Path $packageDir | Out-Null

          Write-Host "Using configuration: $($env:CONFIGURATION)"
          Write-Host "Using version: $env:BUILD_VERSION"
          Write-Host "Package output directory: $packageDir"

          $manifestPath = "MSIX Installer/Package.appxmanifest"
          [xml]$xml = Get-Content $manifestPath
          $xml.Package.Identity.Version = $env:BUILD_VERSION
          $xml.Save($manifestPath)

          msbuild "MSIX Installer/MSIX Installer.wapproj" `
            /p:Configuration=$env:CONFIGURATION `
            /p:AppxBundle=Always `
            /p:AppxBundlePlatforms="x86|x64|ARM64" `
            /p:UapAppxPackageBuildMode=StoreUpload `
            /p:GenerateAppInstallerFile=false `
            /p:AppxPackageDir="$packageDir" `
            /p:AppxPackageSigningEnabled=true `
            /p:PackageCertificateKeyFile="$env:signing_pfx_path" `
            /p:PackageCertificatePassword="$env:signing_pfx_password" `
            /p:AppxAutoIncrementPackageRevision=false `
            /p:AppxPackageVersion=$env:BUILD_VERSION `
            /p:Version=$env:BUILD_VERSION `
            /p:AssemblyVersion=$env:BUILD_VERSION `
            /p:FileVersion=$env:BUILD_VERSION `
            /p:InformationalVersion=$env:BUILD_VERSION

          "PACKAGE_DIR=$packageDir" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

      - name: Create pull request
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.PULL_REQUEST_TOKEN != '' && secrets.PULL_REQUEST_TOKEN || github.token }}
          commit-message: "chore: update nuget packages"
          title: "chore: nightly dependency update"
          body: |
            - Update NuGet packages using dotnet-outdated.
            - Use the latest .NET LTS SDK during the update run.
          branch: chore/nightly-dependency-update
          delete-branch: true
